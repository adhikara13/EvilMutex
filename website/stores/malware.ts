import { defineStore } from 'pinia'
import Fuse from 'fuse.js'
import type {
  MalwareData,
  SearchFilters,
  SearchResult,
  StatisticsData,
  MalwareListResponse
} from '~/types'
import {
  generateJsonResponse,
  generateStatistics,
  generateSigmaRule,
  generateCsvExport,
  generateDetailedCsvExport
} from '~/utils/dataProcessor'

export const useMalwareStore = defineStore('malware', {
  state: () => ({
    malwareList: [] as MalwareData[],
    filteredMalware: [] as MalwareData[],
    loading: false,
    error: null as string | null,
    searchQuery: '',
    activeFilters: {
      category: '',
      tags: [],
      family: '',
      analyst: '',
      dateFrom: '',
      dateTo: ''
    } as SearchFilters,

    selectedMalware: null as MalwareData | null,
    showSigmaRule: false,
    viewMode: 'grid' as 'grid' | 'list',

    statistics: null as StatisticsData | null,
    lastUpdated: null as Date | null
  }),

  getters: {

    totalMalware: (state) => {
      try {
        return state.malwareList?.length || 0
      } catch (error) {
        console.error('Error calculating totalMalware:', error)
        return 0
      }
    },

    totalMutexes: (state) => {
      try {
        if (!state.malwareList || !Array.isArray(state.malwareList)) return 0
        return state.malwareList.reduce((sum, m) => {
          if (!m?.mutexes || !Array.isArray(m.mutexes)) return sum
          return sum + m.mutexes.length
        }, 0)
      } catch (error) {
        console.error('Error calculating totalMutexes:', error)
        return 0
      }
    },

    totalFamilies: (state) => {
      try {
        if (!state.malwareList || !Array.isArray(state.malwareList)) return 0
        const families = new Set(state.malwareList
          .filter(m => m?.malware_info?.family)
          .map(m => m.malware_info.family)
        )
        return families.size
      } catch (error) {
        console.error('Error calculating totalFamilies:', error)
        return 0
      }
    },

    categories: (state) => {
      try {
        if (!state.malwareList || !Array.isArray(state.malwareList)) return []
        const categories = new Set(state.malwareList
          .filter(m => m?.category)
          .map(m => m.category)
        )
        return Array.from(categories).sort()
      } catch (error) {
        console.error('Error getting categories:', error)
        return []
      }
    },

    availableCategories: (state) => {
      try {
        if (!state.malwareList || !Array.isArray(state.malwareList)) return []
        const categories = new Set(state.malwareList
          .filter(m => m?.category)
          .map(m => m.category)
        )
        return Array.from(categories).sort()
      } catch (error) {
        console.error('Error getting availableCategories:', error)
        return []
      }
    },

    availableTags: (state) => {
      try {
        if (!state.malwareList || !Array.isArray(state.malwareList)) return []
        const tags = new Set(state.malwareList
          .filter(m => m?.primary_tags && Array.isArray(m.primary_tags))
          .flatMap(m => m.primary_tags)
        )
        return Array.from(tags).sort()
      } catch (error) {
        console.error('Error getting availableTags:', error)
        return []
      }
    },

    availableFamilies: (state) => {
      try {
        if (!state.malwareList || !Array.isArray(state.malwareList)) return []
        const families = new Set(state.malwareList
          .filter(m => m?.malware_info?.family)
          .map(m => m.malware_info.family)
        )
        return Array.from(families).sort()
      } catch (error) {
        console.error('Error getting availableFamilies:', error)
        return []
      }
    },

    availableAnalysts: (state) => {
      try {
        if (!state.malwareList || !Array.isArray(state.malwareList)) return []
        const analysts = new Set(state.malwareList
          .filter(m => m?.mutexes && Array.isArray(m.mutexes))
          .flatMap(m => m.mutexes
            .filter(mutex => mutex?.analyst)
            .map(mutex => mutex.analyst)
          )
        )
        return Array.from(analysts).sort()
      } catch (error) {
        console.error('Error getting availableAnalysts:', error)
        return []
      }
    },

    searchResults: (state) => {
      try {
        if (!state.malwareList || !Array.isArray(state.malwareList)) return []

        if (!state.searchQuery && !hasActiveFilters(state.activeFilters)) {
          return state.malwareList
        }

        let results = [...state.malwareList]

        if (state.searchQuery) {
          const fuse = new Fuse(state.malwareList, {
            keys: [
              'malware_info.family',
              'malware_info.description',
              'malware_info.aliases',
              'primary_tags',
              'mutexes.name',
              'mutexes.analyst'
            ],
            threshold: 0.3,
            includeScore: true,
            includeMatches: true
          })

          const searchResults = fuse.search(state.searchQuery)
          results = searchResults.map(result => result.item)
        }

        if (state.activeFilters.category) {
          results = results.filter(m => m?.category === state.activeFilters.category)
        }

        if (state.activeFilters.tags && Array.isArray(state.activeFilters.tags) && state.activeFilters.tags.length > 0) {
          results = results.filter(m =>
            m?.primary_tags && Array.isArray(m.primary_tags) &&
            state.activeFilters.tags!.some(tag => m.primary_tags.includes(tag))
          )
        }

        if (state.activeFilters.family) {
          results = results.filter(m => m?.malware_info?.family === state.activeFilters.family)
        }

        if (state.activeFilters.analyst) {
          results = results.filter(m =>
            m?.mutexes && Array.isArray(m.mutexes) &&
            m.mutexes.some(mutex => mutex?.analyst === state.activeFilters.analyst)
          )
        }

        if (state.activeFilters.dateFrom || state.activeFilters.dateTo) {
          results = results.filter(m => {
            if (!m?.mutexes || !Array.isArray(m.mutexes)) return false

            try {
              const malwareDates = m.mutexes
                .filter(mutex => mutex?.date_added)
                .map(mutex => new Date(mutex.date_added))

              if (malwareDates.length === 0) return false

              const minDate = Math.min(...malwareDates.map(d => d.getTime()))
              const maxDate = Math.max(...malwareDates.map(d => d.getTime()))

              if (state.activeFilters.dateFrom && minDate < new Date(state.activeFilters.dateFrom).getTime()) {
                return false
              }

              if (state.activeFilters.dateTo && maxDate > new Date(state.activeFilters.dateTo).getTime()) {
                return false
              }

              return true
            } catch (error) {
              console.error('Error filtering by date:', error)
              return false
            }
          })
        }

        return results
      } catch (error) {
        console.error('Error in searchResults getter:', error)
        return []
      }
    },

    currentStatistics: (state) => {
      try {
        if (!state.statistics) {
          return generateStatistics(state.malwareList || [])
        }
        return state.statistics
      } catch (error) {
        console.error('Error generating statistics:', error)
        return {
          totalMalware: 0,
          totalMutexes: 0,
          categoryCounts: {},
          tagCounts: {},
          familyCounts: {},
          analystCounts: {},
          monthlyTrends: []
        }
      }
    },

    searchSuggestions: (state) => {
      try {
        if (!state.searchQuery || state.searchQuery.length < 2 || !state.malwareList || !Array.isArray(state.malwareList)) {
          return []
        }

        const suggestions = new Set<string>()
        const query = state.searchQuery.toLowerCase()

        state.malwareList.forEach(malware => {
          if (!malware) return

          if (malware.malware_info?.family && malware.malware_info.family.toLowerCase().includes(query)) {
            suggestions.add(malware.malware_info.family)
          }

          if (malware.malware_info?.family && malware.malware_info.family.toLowerCase().includes(query)) {
            suggestions.add(malware.malware_info.family)
          }

          if (malware.malware_info?.aliases && Array.isArray(malware.malware_info.aliases)) {
            malware.malware_info.aliases.forEach(alias => {
              if (alias && alias.toLowerCase().includes(query)) {
                suggestions.add(alias)
              }
            })
          }

          if (malware.primary_tags && Array.isArray(malware.primary_tags)) {
            malware.primary_tags.forEach(tag => {
              if (tag && tag.toLowerCase().includes(query)) {
                suggestions.add(tag)
              }
            })
          }

          if (malware.mutexes && Array.isArray(malware.mutexes)) {
            malware.mutexes.forEach(mutex => {
              if (mutex?.name && mutex.name.toLowerCase().includes(query)) {
                suggestions.add(mutex.name)
              }
            })
          }
        })

        return Array.from(suggestions).slice(0, 10)
      } catch (error) {
        console.error('Error generating search suggestions:', error)
        return []
      }
    }
  },

  actions: {

    async loadMalwareData() {
      if (this.loading) {
        console.log('‚è≥ Already loading malware data...')
        return
      }

      this.loading = true
      this.error = null

      const dataUrl = '/data/malware.json'

      try {
        console.log('üîç Loading malware data...')

        if (!this.malwareList || !Array.isArray(this.malwareList)) {
          this.malwareList = []
        }

        const response = await fetch(dataUrl)

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`)
        }

        const data = await response.json()
        console.log('üìä Loaded data:', data)

        if (data && Array.isArray(data.malware) && data.malware.length > 0) {

          const validMalware = data.malware.filter(item => {
            return item &&
                   item.malware_info &&
                   item.malware_info.family &&
                   Array.isArray(item.mutexes)
          })

          this.malwareList = validMalware
          console.log(`‚úÖ Loaded ${this.malwareList.length} valid malware entries`)
          console.log('üìã Available categories:', this.availableCategories)
          console.log('üë• Available families:', this.availableFamilies)
        } else if (data && data.malware && !Array.isArray(data.malware)) {
          throw new Error('Invalid data structure: malware is not an array')
        } else {
          throw new Error('Invalid data structure: missing or empty malware array')
        }

        this.lastUpdated = new Date()
        this.updateStatistics()
      } catch (error) {
        this.error = error instanceof Error ? error.message : 'Failed to load malware data'
        console.error('‚ùå Error loading malware data:', error)
        console.error('Response URL:', dataUrl)

        if (!Array.isArray(this.malwareList)) {
          this.malwareList = []
        }
      } finally {
        this.loading = false
      }
    },

    setSearchQuery(query: string) {
      this.searchQuery = query
    },

    clearSearch() {
      this.searchQuery = ''
      this.activeFilters = {
        category: '',
        tags: [],
        family: '',
        analyst: '',
        dateFrom: '',
        dateTo: ''
      }
    },

    setFilter(key: keyof SearchFilters, value: any) {
      this.activeFilters[key] = value
    },

    addTagFilter(tag: string) {
      if (!this.activeFilters.tags) {
        this.activeFilters.tags = []
      }
      if (!this.activeFilters.tags.includes(tag)) {
        this.activeFilters.tags.push(tag)
      }
    },

    removeTagFilter(tag: string) {
      if (this.activeFilters.tags) {
        this.activeFilters.tags = this.activeFilters.tags.filter(t => t !== tag)
      }
    },

    clearFilters() {
      this.activeFilters = {
        category: '',
        tags: [],
        family: '',
        analyst: '',
        dateFrom: '',
        dateTo: ''
      }
    },

    selectMalware(malware: MalwareData) {
      this.selectedMalware = malware
    },

    clearSelection() {
      this.selectedMalware = null
      this.showSigmaRule = false
    },

    toggleSigmaRule() {
      this.showSigmaRule = !this.showSigmaRule
    },

    setViewMode(mode: 'grid' | 'list') {
      this.viewMode = mode
    },

    async exportToJson(filters?: SearchFilters): Promise<MalwareListResponse> {
      const filteredData = filters ? this.malwareList.filter(m => this.applyFilters(m, filters)) : this.malwareList
      return generateJsonResponse(filteredData, filters)
    },

    async exportToCsv(filters?: SearchFilters, detailed: boolean = false): Promise<string> {
      const filteredData = filters ? this.malwareList.filter(m => this.applyFilters(m, filters)) : this.malwareList
      if (detailed) {
        // Using static import instead of dynamic import
        return generateDetailedCsvExport(filteredData)
      }
      return generateCsvExport(filteredData)
    },

    async exportSigmaRule(malware: MalwareData): Promise<string> {
      const sigmaRule = generateSigmaRule(malware)
      return this.formatSigmaRule(sigmaRule)
    },

    updateStatistics() {
      this.statistics = generateStatistics(this.malwareList)
    },

    applyFilters(malware: MalwareData, filters: SearchFilters): boolean {
      if (filters.category && malware.category !== filters.category) {
        return false
      }

      if (filters.tags && filters.tags.length > 0) {
        if (!filters.tags.some(tag => malware.primary_tags.includes(tag))) {
          return false
        }
      }

      if (filters.family && malware.malware_info.family !== filters.family) {
        return false
      }

      if (filters.analyst) {
        if (!malware.mutexes.some(m => m.analyst === filters.analyst)) {
          return false
        }
      }

      return true
    },

    formatSigmaRule(rule: any): string {
      return `title: ${rule.title}
id: ${rule.id}
status: ${rule.status}
description: ${rule.description}
license: ${rule.license}
references:
${rule.references.map((ref: string) => `    - ${ref}`).join('\n')}
author: ${rule.author}
date: ${rule.date}
tags:
${rule.tags.map((tag: string) => `    - ${tag}`).join('\n')}
logsource:
    category: ${rule.logsource.category}
    product: ${rule.logsource.product}
detection:
    selection:
        Image|endswith:
${rule.detection.selection['Image|endswith'].map((img: string) => `            - '${img}'`).join('\n')}
        CommandLine|contains:
${rule.detection.selection['CommandLine|contains'].map((cmd: string) => `            - '${cmd}'`).join('\n')}
    condition: ${rule.detection.condition}
falsepositives:
${rule.falsepositives.map((fp: string) => `    - ${fp}`).join('\n')}
level: ${rule.level}`
    }
  }
})

function hasActiveFilters(filters: SearchFilters): boolean {
  return !!(
    filters.category ||
    (filters.tags && filters.tags.length > 0) ||
    filters.family ||
    filters.analyst ||
    filters.dateFrom ||
    filters.dateTo
  )
}